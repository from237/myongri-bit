<html lang="ko"><head><script>(function(firebaseConfig, initialAuthToken, appId) {
        window.__firebase_config = firebaseConfig;
        window.__initial_auth_token = initialAuthToken;
        window.__app_id = appId;
            })("\n{\n  \"apiKey\": \"AIzaSyCqyCcs2R2e7AegGjvFAwG98wlamtbHvZY\",\n  \"authDomain\": \"bard-frontend.firebaseapp.com\",\n  \"projectId\": \"bard-frontend\",\n  \"storageBucket\": \"bard-frontend.firebasestorage.app\",\n  \"messagingSenderId\": \"175205271074\",\n  \"appId\": \"1:175205271074:web:2b7bd4d34d33bf38e6ec7b\"\n}\n","eyJhbGciOiJSUzI1NiIsImtpZCI6IjM3MTE1MjViZGZmNmM4YmM2NjM2NDE3ZjgwOGMzYzFlYTkyN2E0YmMiLCJ0eXAiOiJKV1QifQ.eyJzdWIiOiJmaXJlYmFzZS1hZG1pbnNkay1mYnN2Y0BiYXJkLWZyb250ZW5kLmlhbS5nc2VydmljZWFjY291bnQuY29tIiwiYXVkIjoiaHR0cHM6XC9cL2lkZW50aXR5dG9vbGtpdC5nb29nbGVhcGlzLmNvbVwvZ29vZ2xlLmlkZW50aXR5LmlkZW50aXR5dG9vbGtpdC52MS5JZGVudGl0eVRvb2xraXQiLCJ1aWQiOiIxNzc4ODAxMTQwMjUxNTgzNjgwNSIsImlzcyI6ImZpcmViYXNlLWFkbWluc2RrLWZic3ZjQGJhcmQtZnJvbnRlbmQuaWFtLmdzZXJ2aWNlYWNjb3VudC5jb20iLCJjbGFpbXMiOnsiYXBwSWQiOiJjXzMyODNlNDZiZmZlMjcxZTdfbWJ0aS1zYWp1LWFwcC0xOTkifSwiZXhwIjoxNzUxNTAzMTY2LCJpYXQiOjE3NTE0OTk1NjYsImFsZyI6IlJTMjU2In0.MTs3zkEj1r2XXAbCZ2dsAqj_hD-wWl3r3UlCuSMcOj35kyco6KBWZaGc0p-qLRUuc8pYqB3n6zMp8Dca3-uSL6xwIG9izCKZsgZg-KgEdDJJAxEF-b7uFyLi7lsYS387YCd9y-zpsNbE8OyUhjGVD9DBxxJmrfTxbEAB37HJMEKhIiMEdW9dye80xdvSWGpIhf3A8sW55jnIDH3rd3Qwoia_fr9tLbHtHsB7nJwRTjByFVdF5ua7EQINXOIRBh23yTj73Hta1GeWlyxVgFxI5738IFP5LlfkRxcdJMrI_WoUL4w_xqYNCa2WkXabd8F5ypUH2K0RzOZSkI9p0MZ1Qg","c_3283e46bffe271e7_mbti-saju-app-199")</script><script>(function() {
  // Ensure this script is executed only once
  if (window.firebaseAuthBridgeScriptLoaded) {
    return;
  }
  window.firebaseAuthBridgeScriptLoaded = true;

  let nextTokenPromiseId = 0;

  // Stores { resolve, reject } for ongoing token requests
  const pendingTokenPromises = {};

  // Listen for messages from the Host Application
  window.addEventListener('message', function(event) {

    const messageData = event.data;

  if (messageData && messageData.type === 'RESOLVE_NEW_FIREBASE_TOKEN') {
      const { success, token, error, promiseId } = messageData ?? {};
      if (pendingTokenPromises[promiseId]) {
        if (success) {
          pendingTokenPromises[promiseId].resolve(token);
        } else {
          pendingTokenPromises[promiseId].reject(new Error(error || 'Token refresh failed from host.'));
        }
        delete pendingTokenPromises[promiseId];
      }
    }
  });

  // Expose a function for the Generated App to request a new Firebase token
  window.requestNewFirebaseToken = function() {
    const currentPromiseId = nextTokenPromiseId++;
    const promise = new Promise((resolve, reject) => {
      pendingTokenPromises[currentPromiseId] = { resolve, reject };
    });
    if (window.parent && window.parent !== window) {
      window.parent.postMessage({
        type: 'REQUEST_NEW_FIREBASE_TOKEN',
        promiseId: currentPromiseId
      }, '*');
    } else {
      pendingTokenPromises[currentPromiseId].reject(new Error('No parent window to request token from.'));
      delete pendingTokenPromises[currentPromiseId];
    }
    return promise;
  };
})();</script><script>
let realOriginalGetUserMedia = null;
if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
  realOriginalGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);
}

(function() {
  if (navigator.mediaDevices && navigator.mediaDevices.__proto__) {
    try {
      Object.defineProperty(navigator.mediaDevices.__proto__, 'getUserMedia', {
        get: function() {
          return undefined; // Or throw an error
        },
        configurable: false
      });
    } catch (error) {
      console.error("Error defining prototype getter:", error);
    }
  }
})();

(function() {
  const pendingMediaResolvers = {};
  let nextMediaPromiseId = 0;

  function requestMediaPermissions(constraints) {
    const mediaPromiseId = nextMediaPromiseId++;
    const promise = new Promise((resolve, reject) => {
      pendingMediaResolvers[mediaPromiseId] = (granted) => {
        delete pendingMediaResolvers[mediaPromiseId];
        resolve(granted);
      };
    });

    window.parent.postMessage({
      type: 'requestMediaPermission',
      constraints: constraints,
      promiseId: mediaPromiseId,
    }, '*');

    return promise;
  }

  let originalGetUserMedia = realOriginalGetUserMedia;

  function interceptGetUserMedia() {
    if (navigator.mediaDevices) {
      Object.defineProperty(navigator.mediaDevices, 'getUserMedia', {
        value: function(constraints) {
          return requestMediaPermissions(constraints).then((granted) => {
            if (granted) {
              if (originalGetUserMedia) {
                return originalGetUserMedia(constraints);
              } else {
                throw new Error("Original getUserMedia not available.");
              }
            } else {
              throw new DOMException('Permission denied', 'NotAllowedError');
            }
          });
        },
        writable: false,
        configurable: false
      });
    }
  }

  interceptGetUserMedia();

  const observer = new MutationObserver(function(mutationsList, observer) {
    for (const mutation of mutationsList) {
      if (mutation.type === 'reconfigured' && mutation.name === 'getUserMedia' && mutation.object === navigator.mediaDevices) {
        interceptGetUserMedia();
      } else if (mutation.type === 'attributes' && mutation.attributeName === 'getUserMedia' && mutation.target === navigator.mediaDevices) {
        interceptGetUserMedia();
      } else if (mutation.type === 'childList' && mutation.addedNodes) {
        mutation.addedNodes.forEach(node => {
          if (node === navigator.mediaDevices) {
            interceptGetUserMedia();
          }
        });
      }
    }
  });

  function interceptSpeechRecognition() {
    if (!window.SpeechRecognition && !window.webkitSpeechRecognition) {
      return;
    }

    const OriginalSpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;

    const SpeechRecognitionWrapper = function(...args) {
      const recognizer = new OriginalSpeechRecognition(...args);
      const originalStart = recognizer.start.bind(recognizer);

      recognizer.start = function() {
        requestMediaPermissions({ audio: true }).then(granted => {
          if (granted) {
            originalStart();
          } else {
            const errorEvent = new SpeechRecognitionErrorEvent('error');
            errorEvent.error = 'not-allowed'; // This is the standard error for permission denial.
            recognizer.dispatchEvent(errorEvent);
          }
        });
      };

      return recognizer;
    };

    SpeechRecognitionWrapper.prototype = OriginalSpeechRecognition.prototype;
    SpeechRecognitionWrapper.prototype.constructor = SpeechRecognitionWrapper;

    if (window.SpeechRecognition) {
      window.SpeechRecognition = SpeechRecognitionWrapper;
    }
    if (window.webkitSpeechRecognition) {
      window.webkitSpeechRecognition = SpeechRecognitionWrapper;
    }
  }

  interceptSpeechRecognition();

  window.addEventListener('message', function(event) {
    if (event.data) {
      if (event.data.type === 'resolveMediaPermission') {
        const { promiseId, granted } = event.data;
        if (pendingMediaResolvers[promiseId]) {
          pendingMediaResolvers[promiseId](granted);
        }
      }
    }
  });

})();</script><script>((function(modelInformation) {
  const originalFetch = window.fetch;
  // TODO: b/421908508 - Move these out of the script and match all generative AI model calls.
  let googleLlmBaseApiUrls = [
    'https://generativelanguage.googleapis.com/v1beta/models/' + modelInformation.textModelName + ':streamGenerateContent',
    'https://generativelanguage.googleapis.com/v1beta/models/' + modelInformation.textModelName + ':generateContent',
    'https://generativelanguage.googleapis.com/v1beta/models/' + modelInformation.imageModelName + ':predict',
    'https://generativelanguage.googleapis.com/v1beta/models/' + modelInformation.imageModelName + ':predictLongRunning',
    'https://generativelanguage.googleapis.com/v1beta/models/' + modelInformation.imageEditModelName + ':generateContent',
    'https://generativelanguage.googleapis.com/v1beta/models/' + modelInformation.videoModelName + ':predict',
    'https://generativelanguage.googleapis.com/v1beta/models/' + modelInformation.videoModelName + ':predictLongRunning',
  ];
  modelInformation.deprecatedTextModelNames.forEach((modelName) => {
    googleLlmBaseApiUrls.push(
      'https://generativelanguage.googleapis.com/v1beta/models/' + modelName + ':streamGenerateContent',
      'https://generativelanguage.googleapis.com/v1beta/models/' + modelName + ':generateContent',
    );
  });

  const pendingFetchResolvers = {};
  let nextPromiseId = 0;

  function handleStringInput(input, optionsArgument) {
    const actualUrl = input;
    const fetchCallArgs = [actualUrl, optionsArgument];
    const effectiveOptions = optionsArgument || {};
    const bodyForApiKeyCheck = effectiveOptions.body;
    const bodyForPostMessage = effectiveOptions.body;
    return { actualUrl, fetchCallArgs, effectiveOptions, bodyForApiKeyCheck, bodyForPostMessage };
  }

  function handleRequestInput(input, optionsArgument) {
    const actualUrl = input.url;
    const fetchCallArgs = [input, optionsArgument];
    const effectiveOptions = { method: input.method, headers: new Headers(input.headers) };
    let bodyForApiKeyCheck;
    let bodyForPostMessage;

    if (optionsArgument) {
      if (optionsArgument.method) effectiveOptions.method = optionsArgument.method;
      if (optionsArgument.headers) effectiveOptions.headers = new Headers(optionsArgument.headers);
      if ('body' in optionsArgument) {
        bodyForApiKeyCheck = optionsArgument.body;
        bodyForPostMessage = optionsArgument.body;
      } else {
        bodyForApiKeyCheck = undefined;
        bodyForPostMessage = input.body;
      }
    } else {
      bodyForApiKeyCheck = undefined;
      bodyForPostMessage = input.body;
    }
    return { actualUrl, fetchCallArgs, effectiveOptions, bodyForApiKeyCheck, bodyForPostMessage };
  }

  window.fetch = function(input, optionsArgument) {
    let actualUrl;
    let fetchCallArgs;
    let effectiveOptions = {};
    let bodyForApiKeyCheck;
    let bodyForPostMessage;

    if (typeof input === 'string') {
      ({actualUrl, fetchCallArgs, effectiveOptions, bodyForApiKeyCheck, bodyForPostMessage} = handleStringInput(input, optionsArgument));
    } else if (input instanceof Request) {
      ({actualUrl, fetchCallArgs, effectiveOptions, bodyForApiKeyCheck, bodyForPostMessage} = handleRequestInput(input, optionsArgument));
    } else {
      return originalFetch.apply(window, [input, optionsArgument]);
    }

    effectiveOptions.method = effectiveOptions.method || 'GET';
    if (!effectiveOptions.headers) {
      effectiveOptions.headers = new Headers();
    }


    if (typeof actualUrl === 'string' && googleLlmBaseApiUrls.some((url) => actualUrl.startsWith(url))) {
      let apiKeyIsNull = true;

      const regex = new RegExp("models/([^:]+)");
      const modelNameMatch = actualUrl.match(regex);
      const modelName = modelNameMatch ? modelNameMatch[1] : 'unspecified';


      try {
        const urlObject = new URL(actualUrl);  // Use URL object for robust parsing
        const apiKeyParam = urlObject.searchParams.get('key');
        if (apiKeyParam) {
          apiKeyIsNull = false;
        }
      } catch (e) {
        // Continue checks even if URL parsing fails
      }

      if (apiKeyIsNull && effectiveOptions.headers) {
        const h = new Headers(effectiveOptions.headers);
        const apiKeyHeaderValue = h.get('X-API-Key') || h.get('x-api-key');
        if (apiKeyHeaderValue) {
          apiKeyIsNull = false;
          return originalFetch.apply(window, fetchCallArgs);
        }
      }

      if (apiKeyIsNull && effectiveOptions.method && ['POST', 'PUT', 'PATCH'].includes(effectiveOptions.method.toUpperCase()) && typeof bodyForApiKeyCheck === 'string') {
        try {
          const bodyData = JSON.parse(bodyForApiKeyCheck);
          if (bodyData && bodyData.apiKey) {
            apiKeyIsNull = false;
            return originalFetch.apply(window, fetchCallArgs);
          }
        } catch (e) {
          // Ignore JSON parsing errors
        }
      }

      if(apiKeyIsNull) {
        const promiseId = nextPromiseId++;
        const promise = new Promise((resolve) => {
          pendingFetchResolvers[promiseId] = (resolvedResponse) => {
            delete pendingFetchResolvers[promiseId];
            resolve(resolvedResponse);
          };
        });

        let serializedBodyForPostMessage;
        if (typeof bodyForPostMessage === 'string' || bodyForPostMessage == null) {
            serializedBodyForPostMessage = bodyForPostMessage;
        } else if (bodyForPostMessage instanceof ReadableStream) {
            serializedBodyForPostMessage = null;
        } else {
            try {
                serializedBodyForPostMessage = JSON.stringify(bodyForPostMessage);
            } catch (e) {
                serializedBodyForPostMessage = null;
            }
        }

        const messageOptions = {
            method: effectiveOptions.method,
            headers: Object.fromEntries(new Headers(effectiveOptions.headers).entries()),
            body: serializedBodyForPostMessage
        };

        window.parent.postMessage({
          type: 'requestFetch',
          url: actualUrl,
          modelName: modelName,
          options: messageOptions,
          promiseId: promiseId,
        }, '*');

        return promise;
      }
      return originalFetch.apply(window, fetchCallArgs);
    }
    return originalFetch.apply(window, fetchCallArgs);
  };

  window.addEventListener('message', function(event) {
    if (event.data && event.data.type === 'resolveFetch') {
      const { promiseId, response } = event.data;
      if (pendingFetchResolvers[promiseId]) {
        try {
          const reconstructedResponse = new Response(response.body, {
            status: response.status,
            statusText: response.statusText,
            headers: new Headers(response.headers),
          });
          pendingFetchResolvers[promiseId](reconstructedResponse);
        } catch (error) {
          pendingFetchResolvers[promiseId](new Response(null, { status: 500, statusText: "Interceptor Response Reconstruction Error" }));
        }
      }
    }
  });

}))({"textModelName":"gemini-2.5-flash-preview-04-17","imageModelName":"imagen-3.0-generate-002","imageEditModelName":"gemini-2.0-flash-preview-image-generation","videoModelName":"veo-2.0-generate-001","deprecatedTextModelNames":["gemini-2.0-flash"]})</script><script>(function() {
  const originalConsoleLog = console.log;
  const originalConsoleError = console.error;

    /**
   * Normalizes an error event or a promise rejection reason into a structured error object.
   * @param {*} errorEventOrReason The error object or reason.
   * @return {object} Structured error data { message, name, stack }.
   */
  function getErrorObject(errorEventOrReason) {
    if (errorEventOrReason instanceof Error) {
      return {
        message: errorEventOrReason.message,
        name: errorEventOrReason.name,
        stack: errorEventOrReason.stack,
      };
    }
    // Fallback for non-Error objects.
    try {
      return {
        message: JSON.stringify(errorEventOrReason),
        name: 'UnknownErrorType',
        stack: null,
      };
    } catch (e) {
      return {
        message: String(errorEventOrReason),
        name: 'UnknownErrorTypeNonStringifiable',
        stack: null,
      };
    }
  }

  /**
   * Converts an array of arguments (from log/error) into a single string.
   * Handles Error objects specially to include their message and stack.
   * @param {Array<*>} args - Arguments passed to console methods.
   * @return {string} A string representation of the arguments.
   */
  function stringifyArgs(args) {
    return args
      .map((arg) => {
        if (arg instanceof Error) {
          const {message, stack} = arg;
          return `Error: ${message}${stack ? ('\nStack: ' + stack) : ''}`;
        }
        if (typeof arg === 'object' && arg !== null) {
          try {
            return JSON.stringify(arg);
          } catch (error) {
            return '[Circular Object]';
          }
        } else {
          return String(arg);
        }
      })
      .join(' ');
  }

  console.log = function(...args) {
    const logString = stringifyArgs(args);
    window.parent.postMessage({ type: 'log', message: logString }, '*');
    originalConsoleLog.apply(console, args);
  };

  console.error = function(...args) {
    let errorData;
    if (args.length > 0 && args[0] instanceof Error) {
      const err = args[0];
      // If the first arg is an Error, capture its details.
      errorData = {
        type: 'error',
        source: 'CONSOLE_ERROR',
        ...getErrorObject(err),
        rawArgsString: stringifyArgs(args.slice(1)),
        timestamp: new Date().toISOString(),
      };
    } else {
      // If not an Error object, treat all args as a general error message.
      errorData = {
        type: 'error',
        source: 'CONSOLE_ERROR',
        message: stringifyArgs(args),
        name: 'ConsoleLoggedError',
        stack: null,
        timestamp: new Date().toISOString(),
      };
    }
    window.parent.postMessage(errorData, '*');
    originalConsoleError.apply(console, args);
  };

  // Listen for global unhandled synchronous errors.
  window.addEventListener('error', function(event) {
    const errorDetails = event.error ? getErrorObject(event.error) : {
      message: event.message,
      name: 'GlobalError',
      stack: null,
      filename: event.filename,
      lineno: event.lineno,
      colno: event.colno,
    };

    window.parent.postMessage({
      type: 'error',
      source: 'global',
      ...errorDetails,
      message: errorDetails.message || event.message,
      timestamp: new Date().toISOString(),
    }, '*');
  });

  // Listen for unhandled promise rejections (asynchronous errors).
  window.addEventListener('unhandledrejection', function(event) {
    const errorDetails = getErrorObject(event.reason);

    window.parent.postMessage({
      type: 'error',
      source: 'unhandledrejection',
      ...errorDetails,
      message: errorDetails.message || 'Unhandled Promise Rejection',
      timestamp: new Date().toISOString(),
    }, '*');
  });

})();</script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>명리BTI - 나와 우주가 만나는 순간</title>
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;700&amp;display=swap" rel="stylesheet">
    
    <style>
        /* 기본 스타일 및 변수 설정 */
        :root {
            --bg-color: #1a1a2e;
            --primary-color: #16213e;
            --secondary-color: #0f3460;
            --accent-color: #e94560;
            --text-color: #dcdcdc;
            --light-text-color: #a4a4b3;
            --card-bg: #1f2847;
        }

        /* 기본 HTML 요소 스타일 초기화 */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
            width: 100%;
        }

        body {
            font-family: 'Noto Sans KR', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 1rem;
        }

        /* 컨테이너 및 페이지 레이아웃 */
        .container {
            width: 100%;
            max-width: 480px;
            height: 100%;
            max-height: 800px;
            background-color: var(--primary-color);
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .page {
            display: none; /* 모든 페이지는 기본적으로 숨김 */
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            text-align: center;
            padding: 2rem;
            height: 100%;
            overflow-y: auto;
            animation: fadeIn 0.5s ease-in-out;
        }

        .page.active {
            display: flex; /* 활성화된 페이지만 보임 */
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* 헤더, 메인, 푸터 공통 스타일 */
        header, main, footer {
            width: 100%;
        }

        /* 버튼 스타일 */
        .btn {
            background-color: var(--accent-color);
            color: white;
            border: none;
            border-radius: 50px;
            padding: 1rem 2rem;
            font-size: 1.1rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(233, 69, 96, 0.4);
        }

        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(233, 69, 96, 0.6);
        }

        /* 메인 페이지 스타일 */
        #main-page .subtitle {
            font-size: 1.2rem;
            color: var(--light-text-color);
            margin-top: 0.5rem;
            line-height: 1.6;
        }
        #main-page .main-image {
            margin: 3rem 0;
            animation: float 3s ease-in-out infinite;
        }
        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-15px); }
        }
        #main-page .intro-text p {
            margin-bottom: 1.5rem;
            font-size: 1.1rem;
            line-height: 1.7;
        }

        /* 테스트 페이지 스타일 */
        #test-page .progress-bar {
            width: 100%;
            height: 10px;
            background-color: var(--secondary-color);
            border-radius: 5px;
            margin: 1rem 0 2rem;
            overflow: hidden;
        }
        #test-page .progress {
            width: 0%;
            height: 100%;
            background-color: var(--accent-color);
            transition: width 0.4s ease-in-out;
        }
        #test-page .question-card {
            background-color: var(--card-bg);
            padding: 2rem;
            border-radius: 15px;
            width: 100%;
        }
        #test-page h3 {
            margin-bottom: 1.5rem;
            font-size: 1.3rem;
            color: var(--text-color);
        }
        #test-page .answer-btn {
            display: block;
            width: 100%;
            background-color: var(--secondary-color);
            color: var(--text-color);
            border: 1px solid var(--secondary-color);
            border-radius: 10px;
            padding: 1rem;
            margin-bottom: 1rem;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: left;
        }
        #test-page .answer-btn:hover {
            background-color: var(--accent-color);
            border-color: var(--accent-color);
        }
        #test-page .birth-input {
            margin-bottom: 1rem;
        }
        #test-page .birth-input label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
        }
        #test-page .birth-input input {
            width: 100%;
            padding: 0.8rem;
            border-radius: 8px;
            border: 1px solid var(--secondary-color);
            background-color: var(--bg-color);
            color: var(--text-color);
            font-size: 1rem;
        }

        /* 로딩 페이지 스타일 */
        #loading-page .loader {
            border: 8px solid var(--secondary-color);
            border-top: 8px solid var(--accent-color);
            border-radius: 50%;
            width: 80px;
            height: 80px;
            animation: spin 1s linear infinite;
            margin-bottom: 2rem;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        #loading-page p {
            font-size: 1.2rem;
            color: var(--light-text-color);
        }

        /* 결과 페이지 스타일 */
        #result-page {
            justify-content: flex-start;
        }
        #result-page header {
            margin-bottom: 1.5rem;
        }
        #result-page #result-title {
            color: var(--accent-color);
            font-size: 1.5rem;
            font-weight: 700;
        }
        .result-section {
            background-color: var(--card-bg);
            border-radius: 15px;
            padding: 1.5rem;
            margin-bottom: 1rem;
            text-align: left;
            width: 100%;
        }
        .result-section h3 {
            font-size: 1.2rem;
            color: var(--accent-color);
            margin-bottom: 0.8rem;
        }
        .result-section p {
            font-size: 1rem;
            line-height: 1.7;
            color: var(--light-text-color);
        }
        #result-page footer {
            margin-top: 1rem;
        }
        .share-buttons {
            display: flex;
            gap: 1rem;
            margin-top: 1rem;
            justify-content: center;
        }
        .share-buttons button {
            background-color: var(--secondary-color);
            border: none;
            color: white;
            padding: 0.8rem 1.5rem;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
        }
        .restart-button {
            display: inline-block;
            margin-top: 1.5rem;
            background: none;
            border: 1px solid var(--accent-color);
            color: var(--accent-color);
            padding: 0.8rem 1.5rem;
            border-radius: 50px;
            text-decoration: none;
            font-weight: 500;
        }
    </style>
</head>
<body>

    <div class="container">
        <!-- ==================== 메인 페이지 ==================== -->
        <div id="main-page" class="page active">
            <header>
                <h1>명리BTI</h1>
                <p class="subtitle">MBTI와 사주팔자로 알아보는<br>진짜 내 모습 이야기</p>
            </header>
            <main>
                <div class="main-image">
                    <img src="https://placehold.co/200x200/1a1a2e/e94560?text=✨" alt="명리BTI 대표 이미지">
                </div>
                <div class="intro-text">
                    <p>MBTI 결과만으론 2% 부족했나요?<br>수천 년의 지혜와 현대 심리학의 만남!</p>
                </div>
            </main>
            <footer>
                <button id="start-btn" class="btn">내 본캐 찾으러 가기!</button>
                <button id="download-btn" class="btn" style="background-color: var(--secondary-color); margin-top: 1rem; font-size: 0.9rem;">HTML 파일 다운로드</button>
            </footer>
        </div>

        <!-- ==================== 테스트 페이지 ==================== -->
        <div id="test-page" class="page">
            <header>
                <div class="progress-bar">
                    <div id="progress" class="progress"></div>
                </div>
            </header>
            <main>
                <div id="question-container" class="question-card">
                    <!-- 질문이 여기에 동적으로 삽입됩니다. -->
                </div>
            </main>
            <footer></footer>
        </div>

        <!-- ==================== 로딩 페이지 ==================== -->
        <div id="loading-page" class="page">
            <main>
                <div class="loader"></div>
                <p>당신의 우주를 분석하는 중...</p>
            </main>
        </div>

        <!-- ==================== 결과 페이지 ==================== -->
        <div id="result-page" class="page">
            <header>
                <p><strong id="user-name-result"></strong>님을 위한 명리BTI 분석 리포트</p>
                <h2 id="result-title"></h2>
            </header>
            <main>
                <section class="result-section">
                    <h3 id="result-synergy-title"></h3>
                    <p id="result-synergy-text"></p>
                </section>
                <section class="result-section">
                    <h3 id="result-clash-title"></h3>
                    <p id="result-clash-text"></p>
                </section>
                <section class="result-section">
                    <h3 id="result-advice-title"></h3>
                    <p id="result-advice-text"></p>
                </section>
                <section class="result-section">
                    <h3 id="result-gunghap-title"></h3>
                    <p id="result-gunghap-text"></p>
                </section>
            </main>
            <footer>
                <div class="share-section">
                    <p><strong>내 결과, 친구에게도 공유하기!</strong></p>
                    <div class="share-buttons">
                        <button id="link-copy-btn">🔗 링크 복사</button>
                    </div>
                </div>
                <a href="#" id="restart-btn" class="restart-button">테스트 다시하기</a>
            </footer>
        </div>
    </div>

    <script>
        // ==================== 데이터 영역 ====================
        const questions = [
            { q: "드디어 주말! 내 상태는?", a: [{ text: "이번 주 핫플 어디? 당장 약속 잡아야지!", type: "E" }, { text: "아무도 날 찾지 마… 침대랑 합체해야 해.", type: "I" }] },
            { q: "낯선 파티에 갔을 때 나는?", a: [{ text: "오히려 좋아! 새로운 사람들과 에너지 풀충전!", type: "E" }, { text: "아는 얼굴 어디 없나... 조용히 구석에서 폰만 본다.", type: "I" }] },
            { q: "맛집 얘기를 할 때 나는?", a: [{ text: "거기 평점 4.5점, 시그니처 메뉴는 OOO!", type: "S" }, { text: "뭔가 아늑하고 감성적인 분위기? 가보고 싶어!", type: "N" }] },
            { q: "새 프로젝트를 시작할 때?", a: [{ text: "일단 할 일 리스트업부터! 구체적인 계획이 먼저!", type: "S" }, { text: "이걸로 뭘 할 수 있을까? 전체적인 큰 그림부터!", type: "N" }] },
            { q: "친구가 헤어졌다고 울 때 나의 첫 마디는?", a: [{ text: "왜? 무슨 일이었는데? 객관적 상황 파악부터.", type: "T" }, { text: "아이고, 어떡해... 너무 힘들겠다. 일단 괜찮아?", type: "F" }] },
            { q: "내가 더 듣고 싶은 칭찬은?", a: [{ text: "일 진짜 똑 부러지게 잘한다! 완전 스마트해!", type: "T" }, { text: "너랑 있으면 마음이 편안해져. 정말 따뜻한 사람이야.", type: "F" }] },
            { q: "해외여행을 간다면 나의 스타일은?", a: [{ text: "분 단위로 짜인 엑셀 시트! 완벽한 계획!", type: "J" }, { text: "항공권과 숙소만 예약하고, 나머진 발길 닿는 대로~", type: "P" }] },
            { q: "오늘 할 일을 내일로 미룰 수 있다면?", a: [{ text: "찝찝해서 안돼. 오늘 일은 오늘 끝내야지.", type: "J" }, { text: "내일의 내가 알아서 하겠지! 일단 좀 쉬자.", type: "P" }] }
        ];

        const birthQuestion = {
            q: "거의 다 왔어요!",
            sub_q: "더 깊은 분석을 위해 태어난 정보를 알려주세요.",
            is_birth: true
        };

        const resultsData = {
            'ISTJ_정화': {
                title: '현실주의 횃불, ISTJ x 정화(丁火) 타입',
                synergy: { title: '🔥 시너지 포인트: 완벽주의 해결사', text: 'ISTJ의 꼼꼼함과 책임감에, 어둠 속에서도 길을 찾는 횃불의 집중력과 통찰력이 더해졌어요. 맡은 일은 오차 없이 반드시 해내는 \'믿고 맡기는 해결사\' 스타일! 복잡한 문제도 디테일을 놓치지 않으면서 핵심을 꿰뚫어 보니, 주변에선 "역시 당신이다!"라는 말을 자주 들으실 거예요.' },
                clash: { title: '💧 클래시 포인트: 내 안의 불과 물의 전쟁', text: '하지만 가끔은 내 안의 열정이 너무 뜨거워 스스로를 태울 때가 있어요. 계획이 조금이라도 틀어지면 엄청난 스트레스를 받죠. 마치 잘 타오르던 횃불에 갑자기 차가운 \'물(水)\'이 쏟아지는 것처럼요. 겉으로는 차분하지만, 내면에서는 \'이성 vs 감성\', \'계획 vs 변수\'의 싸움이 치열하게 일어나고 있을 가능성이 높아요.' },
                advice: { title: '💡 당신을 위한 삶의 조언: \'성과 코인\' 모으기', text: '완벽한 계획도 중요하지만 때로는 유연함이 더 큰 성과를 가져다준답니다. \'아침 9시까지 출근\' 같이 아주 작은 성공을 스스로 칭찬해주세요. 결과물을 내는 취미는 당신에게 아주 좋은 에너지를 줄 거예요.' },
                gunghap: { title: '💖 환상의 궁합', text: '당신의 계획성을 존중해주면서도, 가끔은 예측불허한 즐거움으로 이끌어줄 ENFP와 좋은 시너지를 낼 수 있어요. 사주적으로는, 당신의 작은 불꽃을 큰 바다 위 등대처럼 더욱 빛나게 해 줄 \'큰 물(壬水)\' 에너지를 가진 사람과 최고의 궁합을 자랑한답니다!' }
            },
            'ENFP_갑목': {
                title: '자유로운 영혼의 거목, ENFP x 갑목(甲木) 타입',
                synergy: { title: '🚀 시너지 포인트: 창의력 발전소', text: 'ENFP의 무한한 상상력과 긍정 에너지에, 하늘을 향해 뻗어 나가는 거목 \'갑목(甲木)\'의 성장 에너지가 만났어요. 당신은 아이디어가 샘솟는 \'걸어다니는 창의력 발전소\'! 사람들과 어울리며 새로운 일을 벌이는 것을 즐기고, 그 중심에서 특유의 매력으로 모두를 이끄는 힘이 있습니다.' },
                clash: { title: '🌪️ 클래시 포인트: 용두사미 텐션', text: '다만, 너무 많은 아이디어와 호기심 때문에 한 가지 일에 집중하기 어려울 때가 있어요. 마치 거목이 너무 많은 가지를 뻗어내느라 영양이 분산되는 것과 같죠. 시작은 거창했지만 마무리가 흐지부지되는 \'용두사미\'가 될 수 있으니 경계해야 해요. "아, 저것도 재밌겠다!" 하며 쉽게 마음이 바뀌곤 하죠?' },
                advice: { title: '✂️ 당신을 위한 삶의 조언: \'가지치기\'의 기술', text: '당신에게는 선택과 집중, 즉 \'가지치기\'가 필요해요. 수많은 아이디어 중 "이번 달엔 딱 이거 하나만 제대로 해본다!"고 정해보세요. 꾸준히 기록하는 습관은 당신의 흩어지는 에너지를 모아주는 최고의 뿌리가 될 거예요. 작은 프로젝트라도 끝까지 마무리하는 경험이 중요합니다.' },
                gunghap: { title: '💖 환상의 궁합', text: '당신의 창의력을 현실로 만들어줄 꼼꼼한 INTJ와 환상의 파트너가 될 수 있어요. 사주적으로는, 당신이라는 나무가 뿌리내릴 수 있는 넓고 비옥한 \'대지(戊土)\'의 에너지를 가진 사람과 함께할 때 안정감과 시너지를 얻을 수 있습니다.' }
            }
        };

        // ==================== 상태 변수 ====================
        let currentQuestionIndex = 0;
        let userAnswers = { E: 0, I: 0, S: 0, N: 0, T: 0, F: 0, J: 0, P: 0 };
        
        // ==================== DOM 요소 ====================
        const pages = document.querySelectorAll('.page');
        const startBtn = document.getElementById('start-btn');
        const restartBtn = document.getElementById('restart-btn');
        const linkCopyBtn = document.getElementById('link-copy-btn');
        const downloadBtn = document.getElementById('download-btn');
        
        const questionContainer = document.getElementById('question-container');
        const progressBar = document.getElementById('progress');

        // ==================== 함수 ====================
        function showPage(pageId) {
            pages.forEach(page => {
                page.classList.remove('active');
            });
            document.getElementById(pageId).classList.add('active');
        }

        function displayQuestion() {
            if (currentQuestionIndex < questions.length) {
                const questionData = questions[currentQuestionIndex];
                let answersHtml = questionData.a.map(answer => 
                    `<button class="answer-btn" data-type="${answer.type}">${answer.text}</button>`
                ).join('');
                
                questionContainer.innerHTML = `
                    <h3>Q${currentQuestionIndex + 1}. ${questionData.q}</h3>
                    ${answersHtml}
                `;
                
                document.querySelectorAll('.answer-btn').forEach(button => {
                    button.addEventListener('click', handleAnswer);
                });
            } else {
                displayBirthQuestion();
            }
            updateProgressBar();
        }

        function displayBirthQuestion() {
            questionContainer.innerHTML = `
                <h3>${birthQuestion.q}</h3>
                <p>${birthQuestion.sub_q}</p>
                <div class="birth-input">
                    <label for="username">당신의 이름(닉네임)</label>
                    <input type="text" id="username" placeholder="민준">
                </div>
                <div class="birth-input">
                    <label for="birthdate">생년월일</label>
                    <input type="date" id="birthdate">
                </div>
                <div class="birth-input">
                    <label for="birthtime">태어난 시간</label>
                    <input type="time" id="birthtime">
                </div>
                <button id="submit-btn" class="btn">결과 분석하기</button>
            `;
            document.getElementById('submit-btn').addEventListener('click', handleSubmit);
            updateProgressBar();
        }

        function handleAnswer(e) {
            const type = e.target.dataset.type;
            userAnswers[type]++;
            currentQuestionIndex++;
            displayQuestion();
        }


        function updateProgressBar() {
            const totalSteps = questions.length + 1; // MBTI 질문 + 생년월일 입력
            const progressPercentage = (currentQuestionIndex / totalSteps) * 100;
            progressBar.style.width = `${progressPercentage}%`;
        }
        
        function handleSubmit() {
            const username = document.getElementById('username').value || '사용자';
            const birthdate = document.getElementById('birthdate').value;
            const birthtime = document.getElementById('birthtime').value;

            if (!birthdate || !birthtime) {
                alert('생년월일과 태어난 시간을 모두 입력해주세요!');
                return;
            }
            
            showPage('loading-page');
            
            setTimeout(() => {
                calculateAndShowResult(username, birthdate, birthtime);
            }, 2000); // 2초간 로딩 화면 표시
        }

        function calculateAndShowResult(username, birthdate, birthtime) {
            // 1. MBTI 계산
            let mbti = '';
            mbti += userAnswers.E > userAnswers.I ? 'E' : 'I';
            mbti += userAnswers.S > userAnswers.N ? 'S' : 'N';
            mbti += userAnswers.T > userAnswers.F ? 'T' : 'F';
            mbti += userAnswers.J > userAnswers.P ? 'J' : 'P';
            
            // 2. 사주 계산 (데모용 단순화 로직)
            const month = new Date(birthdate).getMonth() + 1;
            let sajuType = '';
            if (month >= 3 && month <= 8) { // 봄, 여름 -> 나무, 불
                sajuType = mbti.includes('E') || mbti.includes('N') ? '갑목' : '정화';
            } else { // 가을, 겨울 -> 금, 수
                sajuType = mbti.includes('I') || mbti.includes('S') ? '정화' : '갑목';
            }

            // 데모를 위해 ISTJ는 정화, ENFP는 갑목으로 강제 할당
            if (mbti === 'ISTJ') sajuType = '정화';
            if (mbti === 'ENFP') sajuType = '갑목';
            
            const resultKey = `${mbti}_${sajuType}`;
            const resultData = resultsData[resultKey] || resultsData['ISTJ_정화']; // 매칭 결과 없으면 기본값

            // 3. 결과 페이지에 데이터 바인딩
            document.getElementById('user-name-result').innerText = username;
            document.getElementById('result-title').innerText = resultData.title;
            
            document.getElementById('result-synergy-title').innerText = resultData.synergy.title;
            document.getElementById('result-synergy-text').innerText = resultData.synergy.text;
            
            document.getElementById('result-clash-title').innerText = resultData.clash.title;
            document.getElementById('result-clash-text').innerText = resultData.clash.text;

            document.getElementById('result-advice-title').innerText = resultData.advice.title;
            document.getElementById('result-advice-text').innerText = resultData.advice.text;

            document.getElementById('result-gunghap-title').innerText = resultData.gunghap.title;
            document.getElementById('result-gunghap-text').innerHTML = resultData.gunghap.text;
            
            showPage('result-page');
        }

        function resetTest() {
            currentQuestionIndex = 0;
            userAnswers = { E: 0, I: 0, S: 0, N: 0, T: 0, F: 0, J: 0, P: 0 };
            progressBar.style.width = '0%';
            showPage('main-page');
        }

        // ==================== 이벤트 리스너 ====================
        startBtn.addEventListener('click', () => {
            showPage('test-page');
            displayQuestion();
        });

        restartBtn.addEventListener('click', (e) => {
            e.preventDefault();
            resetTest();
        });

        linkCopyBtn.addEventListener('click', () => {
            // navigator.clipboard.writeText는 보안 정책상 로컬 파일에서 동작하지 않을 수 있습니다.
            // 임시로 alert를 사용하며, 실제 서버 배포 시에는 아래 코드가 정상 동작합니다.
            try {
                navigator.clipboard.writeText(window.location.href);
                alert('링크가 복사되었어요!');
            } catch (err) {
                 alert('링크 복사에 실패했어요. HTTPS 환경에서 다시 시도해주세요.');
            }
        });

        downloadBtn.addEventListener('click', () => {
            try {
                const htmlContent = document.documentElement.outerHTML;
                const blob = new Blob([htmlContent], { type: 'text/html;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'mbti-saju-app.html';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            } catch (err) {
                console.error("다운로드 실패:", err);
                alert("파일을 다운로드하는 데 실패했습니다.");
            }
        });

    </script>


</body></html>